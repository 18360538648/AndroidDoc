# 设计模式


##  1. 单例模式(应用最广的模式)
###  1.1 定义

确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

### 1.2 使用场景

确保某个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源或者某种类型的对象应该有且只有一个

###  1.3 具体使用

####  1.3.1 饿汉式单例

在类加载的时候就创建这个单例

```
public class FirstSingleton {
    private static FirstSingleton firstSingleton = new FirstSingleton();
    // 需要将构造方法私有化
    private FirstSingleton() {
    }

    public static FirstSingleton getInstance() {
        return firstSingleton;
    }

}
```

#### 1.3.2 懒汉式单例
再调用`getInstance()`方法时实例化单例对象

```
public class SecondSingleton {
    private SecondSingleton() {
    }

    public static SecondSingleton getInstance() {
        return SecondSingletonHolder.secondSingleton;
    }

    /**
     * 静态内部类
     */
    private static class SecondSingletonHolder {
        private static final SecondSingleton secondSingleton = new SecondSingleton();
    }
}
```

####  1.3.3 DCL单例

```
public class SingleTonDCL {
    private static SingleTonDCL singleTonDCL;

    private SingleTonDCL() {
    }

    public static SingleTonDCL getInstance() {
        if (singleTonDCL == null) { // 避免不必要的同步
            synchronized (SingleTonDCL.class) {
                if (singleTonDCL == null) { // 在singleTonDCL为空的时候再创建实例
                    singleTonDCL = new SingleTonDCL();
                }
            }
        }
        return singleTonDCL;
    }
}
```

###  1.4 优缺点

####  1.4.1 优点 

* 减少内存开支。当一个对象需要频繁地创建和销毁时，而且创建和销毁时性能又没法优化，单例模式的优势就非常明显了。
* 减少系统的性能开销。当一个对象的产生需要比较多的资源时，在应用启动时直接产生一个单例对象，然后用永久存留内存的方式来解决
* 避免对资源的多重暂用

#### 1.4.2 缺点

* 单例模式一般没有接口，扩展很困难，若要扩展除非修改代码
* 单例对象如果持有`Context`,很容易引发内存泄漏，因此传递给单例对象的Context最好时`Application Context`

## 2. Builder模式(自由扩展你的项目)

###  2.1 定义



### 2.2 使用场景

确保某个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源或者某种类型的对象应该有且只有一个

###  2.3 具体使用

### 2.4 优缺点


## 3. Builder模式(自由扩展你的项目)

###  3.1 定义

确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

### 3.2 使用场景

确保某个类有且只有一个对象的场景，避免产生多个对象消耗过多的资源或者某种类型的对象应该有且只有一个

###  3.3 具体使用

### 3.4 优缺点